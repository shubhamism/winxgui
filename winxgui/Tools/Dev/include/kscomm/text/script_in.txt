一、脚本样例

doc = {
	"/*" $(*) "*/" |
	"//" $(*) "\n" |
	"#if" $(*) "#endif" |
	$(_blank) | ";" |
	$(FuncDeclare) ";"
	};

FuncDeclare =
	$(RetType) "__xdecl" $(_blank) 
	"__xcharfunc" $(_blank) "(" $(FuncName) ")" $(_blank)
	"("  $(FuncArgs) ")"
	;

FuncArgs =
	$(_blank) |
	{ $(FuncArg) "," } |
	$(FuncArg)
	;

FuncArg = $(* = ArgType) $(_symbol = ArgName);

doc	- 入口
$(_blank) - 空字符
$(_quomark) - 一个双引号
$(_symbol) - 标识符
$(*) - 不关心的内容
() - 小括号


二、脚本说明

1、该脚本用于描述各种基于文本的语言。从中提取所关心的信息。

2、脚本预期生成的输出是一个树状的信息输出。其父子关系从推导树。
   例如，以上文为例。其树状结构为：
   	<doc>
		<FuncDeclare>
			<RetType>
			<FuncName>
			<FuncArgs>
				<FuncArg>
					<ArgType>
					<ArgName>
   树状信息是通过“推导”生产的。所谓推导，其实只是一种匹配逻辑。详见下文。
   
3、匹配规则
   匹配规则的表达式是：
   	 Rule = ...;
   它描述了匹配是如何进行的。doc是匹配的入口。
   一个匹配规则以;结束。
   
4、推导关系
   从上文可知，常见的推导关系有：
   1）{} 	- 重复
   	  表示一个重复的匹配过程。
   2） | 	- 或者
   	  表示两可选择的匹配过程。当第一个匹配条件不成立时，尝试第二种匹配。
   3）与
   	  与关系其实是最平凡的一种匹配关系。例如：
   	  	doc = "/*" $(*) "*/"
   	  其中 "/*"、$(*)、"*/" 三者就是与关系。只有在第一个条件匹配成立时，才进行下一个匹配。
   3）[]    - 可选内容
      表示可有可无的内容
   	  
4、匹配量
   匹配量大致分为两类：
   1）常量。例如上面的 "/*"、"*/"。
   	  遇到常量匹配量的匹配规则很简单，如果读入的字符与该常量不等，则代表匹配失败。
   2）匹配变量。例如上文的 $(_symbol)、$(RetType)、$(* = ArgType)等。
   	  匹配变量的基本格式为：
   	  	$(Rule = Var)
   	  其中Rule代表匹配规则。可以是：
   	  	$(*)		- 任意字符串。
					  后面必须紧跟一个常量, 或*[常量]，
					  后一个表示遇到这个常量匹配结束，但这个常量不属于这次匹配过程
   	  	$(_csymbol)	- C/C++合法的symbol。
   	  	$(Rule)		- Rule应该是另一个用户定义的匹配规则。
   	  其中Var则代表当匹配成立时，Rule所匹配成功的对应的字符串约束给Var。
   	  Var部分是可选的。
