<html xmlns:ns1="" xmlns:ns0="http://msn.com/Namespaces/spaces.xsd">

<head>
<meta http-equiv=Content-Type content="text/html; charset=gb2312">
<title>VC++ 6.0的小花招</title>

<style>
<!--
 /* Font Definitions */
 @font-face
	{font-family:宋体;
	panose-1:2 1 6 0 3 1 1 1 1 1;}
@font-face
	{font-family:Dotum;
	panose-1:2 11 6 0 0 1 1 1 1 1;}
@font-face
	{font-family:隶书;
	panose-1:2 1 5 9 6 1 1 1 1 1;}
@font-face
	{font-family:"\@隶书";
	panose-1:2 1 5 9 6 1 1 1 1 1;}
@font-face
	{font-family:"\@宋体";
	panose-1:2 1 6 0 3 1 1 1 1 1;}
@font-face
	{font-family:"\@Dotum";
	panose-1:2 11 6 0 0 1 1 1 1 1;}
 /* Style Definitions */
 p.MsoNormal, li.MsoNormal, div.MsoNormal
	{margin:0cm;
	margin-bottom:.0001pt;
	text-align:justify;
	text-justify:inter-ideograph;
	font-size:10.5pt;
	font-family:"Times New Roman";}
h1
	{margin-top:17.0pt;
	margin-right:0cm;
	margin-bottom:16.5pt;
	margin-left:0cm;
	text-align:justify;
	text-justify:inter-ideograph;
	line-height:240%;
	page-break-after:avoid;
	font-size:22.0pt;
	font-family:"Times New Roman";}
p.MsoFootnoteText, li.MsoFootnoteText, div.MsoFootnoteText
	{margin-top:0cm;
	margin-right:0cm;
	margin-bottom:15.6pt;
	margin-left:0cm;
	layout-grid-mode:char;
	font-size:9.0pt;
	font-family:"Times New Roman";}
span.MsoFootnoteReference
	{vertical-align:super;}
p.MsoTitle, li.MsoTitle, div.MsoTitle
	{margin-top:12.0pt;
	margin-right:0cm;
	margin-bottom:3.0pt;
	margin-left:0cm;
	text-align:center;
	font-size:26.0pt;
	font-family:隶书;
	font-weight:bold;}
a:link, span.MsoHyperlink
	{color:blue;
	text-decoration:underline;}
a:visited, span.MsoHyperlinkFollowed
	{color:purple;
	text-decoration:underline;}
p.a, li.a, div.a
	{margin-top:0cm;
	margin-right:0cm;
	margin-bottom:15.6pt;
	margin-left:0cm;
	text-align:center;
	font-size:10.5pt;
	font-family:"Times New Roman";
	font-weight:bold;}
p.a0, li.a0, div.a0
	{margin-top:12.0pt;
	margin-right:0cm;
	margin-bottom:15.6pt;
	margin-left:0cm;
	text-align:center;
	font-size:16.0pt;
	font-family:隶书;
	font-weight:bold;}
p.a1, li.a1, div.a1
	{margin:0cm;
	margin-bottom:.0001pt;
	text-align:justify;
	text-justify:inter-ideograph;
	font-size:14.0pt;
	font-family:"Times New Roman";
	font-weight:bold;}
p.a2, li.a2, div.a2
	{margin:0cm;
	margin-bottom:.0001pt;
	text-align:justify;
	text-justify:inter-ideograph;
	font-size:12.0pt;
	font-family:"Times New Roman";
	font-weight:bold;}
p.a3, li.a3, div.a3
	{margin:0cm;
	margin-bottom:.0001pt;
	font-size:9.0pt;
	font-family:"Courier New";}
 /* Page Definitions */
 @page Section1
	{size:595.3pt 841.9pt;
	margin:72.0pt 90.0pt 72.0pt 90.0pt;
	layout-grid:15.6pt;}
div.Section1
	{page:Section1;}
 /* List Definitions */
 ol
	{margin-bottom:0cm;}
ul
	{margin-bottom:0cm;}
-->
</style>

</head>

<body bgcolor=white lang=ZH-CN link=blue vlink=purple style="TEXT-JUSTIFY-TRIM:
 punctuation">

<div class=Section1 style="LAYOUT-GRID:  15.6pt none">

<p class=MsoTitle><span lang=EN-US>VC++ 6.0</span>的小花招</p>

<p class=MsoNormal><span lang=EN-US></span>&nbsp;</p>

<p class=a0 style="MARGIN:
 3.1pt 0cm"><span style="FONT-WEIGHT: normal">许式伟</span></p>

<p class=a style="MARGIN:
 3.1pt 0cm 15.6pt"><span
 lang=EN-US>2006-2-18</span></p>

<p class=MsoNormal><span lang=EN-US></span>&nbsp;</p>

<p class=MsoNormal><span lang=EN-US>Visual Studio</span><span style="FONT-FAMILY:
 宋体">系列中产品中，</span><span lang=EN-US>Visual Studio 6.0</span><span
 style="FONT-FAMILY: 宋体">是最经典的一个版本，虽然后来有</span><span lang=EN-US>Visual Studio
.NET 2003</span><span style="FONT-FAMILY: 宋体">，以及</span><span lang=EN-US>2005</span><span
 style="FONT-FAMILY: 宋体">，也确实添加了很多让我觉得激动的特性，但是从使用细节的细腻程度上来看，</span><span
 lang=EN-US>VS 6.0</span><span style="FONT-FAMILY: 宋体">无疑是最棒的。我们一些同事甚至试图把</span><span
 lang=EN-US>2005</span><span style="FONT-FAMILY: 宋体">的</span><span lang=EN-US>C++</span><span
 style="FONT-FAMILY: 宋体">编译器独立的拿到</span><span lang=EN-US>Visual Studio 6.0</span><span
 style="FONT-FAMILY: 宋体">中来用，也不愿意升级到</span><span lang=EN-US>.NET</span><span
 style="FONT-FAMILY: 宋体">上来用，可见其魅力。</span></p>

<p class=MsoNormal><span lang=EN-US></span>&nbsp;</p>

<p class=MsoNormal><span style="FONT-FAMILY: 宋体">和</span><span lang=EN-US>VS 6.0</span><span
 style="FONT-FAMILY: 宋体">这个产品的成熟相比，</span><span lang=EN-US>VC++ 6.0</span><span
 style="FONT-FAMILY: 宋体">的编译器的的确确相对来说有些糟糕，其中最被诟病的是对模板技术支持很不好。下面我想做的一件事情，就是向那些继续留恋</span><span
 lang=EN-US>VC++ 6.0</span><span style="FONT-FAMILY: 宋体">的朋友，介绍一些小花招，来避开</span><span
 lang=EN-US>VC++ 6.0</span><span style="FONT-FAMILY: 宋体">的一些编译器缺陷。</span></p>

<p class=MsoNormal><span lang=EN-US></span>&nbsp;</p>

<p class=MsoNormal><b><span lang=EN-US></span></b>&nbsp;</p>

<p class=MsoNormal><b><span lang=EN-US>1</span></b><b><span style="FONT-FAMILY:
 宋体">）</span><span lang=EN-US>for (type var=expression;;) </span></b><b><span
 style="FONT-FAMILY: 宋体">中变量</span><span lang=EN-US>var</span></b><b><span
 style="FONT-FAMILY: 宋体">的作用域问题。</span></b></p>

<p class=MsoNormal><span lang=EN-US></span>&nbsp;</p>

<p class=MsoNormal><span style="FONT-FAMILY: 宋体">按照</span><span lang=EN-US>C++</span><span
 style="FONT-FAMILY: 宋体">标准，这里定义的变量</span><span lang=EN-US>var</span><span
 style="FONT-FAMILY: 宋体">出了</span><span lang=EN-US>for</span><span
 style="FONT-FAMILY: 宋体">循环应该被销毁。也就是说下面这段代码是有效的：</span></p>

<p class=MsoNormal><span lang=EN-US></span>&nbsp;</p>

<p class=a3 style="BACKGROUND: #d9d9d9"><span lang=EN-US>&nbsp;&nbsp; for (int i
= 0; i &lt; 100; ++i)</span></p>

<p class=a3 style="BACKGROUND: #d9d9d9"><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
func();</span></p>

<p class=a3 style="BACKGROUND: #d9d9d9"><span lang=EN-US>&nbsp;&nbsp; for (int i
= 0; i &lt; 100; ++i)</span></p>

<p class=a3 style="BACKGROUND: #d9d9d9"><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
func2();</span></p>

<p class=MsoNormal><span lang=EN-US></span>&nbsp;</p>

<p class=MsoNormal><span style="FONT-FAMILY: 宋体">而下面这段代码应该编译不过：</span></p>

<p class=MsoNormal><span lang=EN-US></span>&nbsp;</p>

<p class=a3 style="BACKGROUND: #d9d9d9"><span lang=EN-US>&nbsp;&nbsp;&nbsp; for
(int i = 0; i &lt; 100; ++i)</span></p>

<p class=a3 style="BACKGROUND: #d9d9d9"><span lang=EN-US>&nbsp;&nbsp;&nbsp; {</span></p>

<p class=a3 style="BACKGROUND: #d9d9d9"><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
if (has_found_it())</span></p>

<p class=a3 style="BACKGROUND: #d9d9d9"><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
{</span></p>

<p class=a3 style="BACKGROUND: #d9d9d9"><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
handle_find_result();</span></p>

<p class=a3 style="BACKGROUND: #d9d9d9"><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
break;</span></p>

<p class=a3 style="BACKGROUND: #d9d9d9"><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
}</span></p>

<p class=a3 style="BACKGROUND: #d9d9d9"><span lang=EN-US>&nbsp;&nbsp;&nbsp; }</span></p>

<p class=a3 style="BACKGROUND: #d9d9d9"><span lang=EN-US>&nbsp;&nbsp;&nbsp; if
(i == 100)</span></p>

<p class=a3 style="BACKGROUND: #d9d9d9"><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
do_not_found();</span></p>

<p class=MsoNormal><span lang=EN-US></span>&nbsp;</p>

<p class=MsoNormal><span style="FONT-FAMILY: 宋体">然而</span><span lang=EN-US>VC++
6.0</span><span style="FONT-FAMILY: 宋体">对于第一段代码会报变量</span><span lang=EN-US>i</span><span
 style="FONT-FAMILY: 宋体">重复定义错误，而第二段代码编译通过。</span></p>

<p class=MsoNormal><span lang=EN-US></span>&nbsp;</p>

<p class=MsoNormal><span style="FONT-FAMILY: 宋体">为了让</span><span lang=EN-US>VC++
6.0</span><span style="FONT-FAMILY: 宋体">的</span><span lang=EN-US>for</span><span
 style="FONT-FAMILY: 宋体">语句看起来符合</span><span lang=EN-US>C++</span><span
 style="FONT-FAMILY: 宋体">标准，你可以这样做：</span></p>

<p class=MsoNormal><span lang=EN-US></span>&nbsp;</p>

<p class=a3 style="BACKGROUND: #d9d9d9"><span lang=EN-US>&nbsp;&nbsp; #define
for if (0); else for</span></p>

<p class=MsoNormal><span lang=EN-US></span>&nbsp;</p>

<p class=MsoNormal><span style="FONT-FAMILY: 宋体">你会发现很有趣，这样</span><span
 lang=EN-US>define</span><span style="FONT-FAMILY: 宋体">一下后，</span><span
 lang=EN-US>VC++ 6.0</span><span style="FONT-FAMILY: 宋体">的</span><span
 lang=EN-US>for</span><span style="FONT-FAMILY: 宋体">语句完全符合</span><span
 lang=EN-US>C++</span><span style="FONT-FAMILY: 宋体">标准了！而且由于编译器的优化，</span><span
 lang=EN-US>Release</span><span style="FONT-FAMILY: 宋体">版本不会增加任何额外的开销。</span></p>

<p class=MsoNormal><span lang=EN-US></span>&nbsp;</p>

<p class=MsoNormal><span style="FONT-FAMILY: 宋体">喜欢</span><span lang=EN-US>“</span><span
 style="FONT-FAMILY: 宋体">钻牛角尖</span><span lang=EN-US>”</span><span
 style="FONT-FAMILY: 宋体">的朋友可能会说：嗯，不错的主意。但是</span><span lang=EN-US>――</span><span
 style="FONT-FAMILY: 宋体">为什么不这样做：</span></p>

<p class=MsoNormal><span lang=EN-US></span>&nbsp;</p>

<p class=a3 style="BACKGROUND: #d9d9d9"><span lang=EN-US>&nbsp;&nbsp; #define
for if (1) for</span></p>

<p class=MsoNormal><span lang=EN-US></span>&nbsp;</p>

<p class=MsoNormal><span style="FONT-FAMILY: 宋体">嗯？看起来也可以。还是让我们看一个用例：</span></p>

<p class=MsoNormal><span lang=EN-US></span>&nbsp;</p>

<p class=a3 style="BACKGROUND: #d9d9d9"><span lang=EN-US>&nbsp;&nbsp; if (cond)</span></p>

<p class=a3 style="BACKGROUND: #d9d9d9"><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
for (int i = 0; i &lt; 100; ++i)</span></p>

<p class=a3 style="BACKGROUND: #d9d9d9"><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
func1();</span></p>

<p class=a3 style="BACKGROUND: #d9d9d9"><span lang=EN-US>&nbsp;&nbsp; else</span></p>

<p class=a3 style="BACKGROUND: #d9d9d9"><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
func2();</span></p>

<p class=MsoNormal><span lang=EN-US></span>&nbsp;</p>

<p class=MsoNormal><span style="FONT-FAMILY: 宋体">进行宏代码展开后，成为：</span></p>

<p class=MsoNormal><span lang=EN-US></span>&nbsp;</p>

<p class=a3 style="BACKGROUND: #d9d9d9"><span lang=EN-US>&nbsp;&nbsp; if (cond)</span></p>

<p class=a3 style="BACKGROUND: #d9d9d9"><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
if (1)</span></p>

<p class=a3 style="BACKGROUND: #d9d9d9"><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
for (int i = 0; i &lt; 100; ++i)</span></p>

<p class=a3 style="BACKGROUND: #d9d9d9"><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
func1();</span></p>

<p class=a3 style="BACKGROUND: #d9d9d9"><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
else</span></p>

<p class=a3 style="BACKGROUND: #d9d9d9"><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
func2();</span></p>

<p class=MsoNormal><span lang=EN-US></span>&nbsp;</p>

<p class=MsoNormal><span style="FONT-FAMILY: 宋体">这个结果显然不能符合我们的原意。这里</span><span
 lang=EN-US>func2();</span><span style="FONT-FAMILY: 宋体">语句永远得不到执行机会。</span></p>

<p class=MsoNormal><span lang=EN-US></span>&nbsp;</p>

<p class=MsoNormal><span lang=EN-US></span>&nbsp;</p>

<a name="RetTypeBug"><p class=MsoNormal><b><span lang=EN-US>2</span></b><b><span style='font-family:
宋体'>）模板参数类型如果不出现在参数列表中，则不能作为返回值类型。</span></b></p></a>

<p class=MsoNormal><span lang=EN-US></span>&nbsp;</p>

<p class=MsoNormal><span style="FONT-FAMILY: 宋体">由于编译器的缺陷，</span><span
 lang=EN-US>VC++ 6.0</span><span style="FONT-FAMILY: 宋体">不支持以下这种用法：</span></p>

<p class=MsoNormal><span lang=EN-US></span>&nbsp;</p>

<p class=a3 style="BACKGROUND: #d9d9d9"><span lang=EN-US>&nbsp;&nbsp; template
&lt;class T1, class T2&gt;</span></p>

<p class=a3 style="BACKGROUND: #d9d9d9"><span lang=EN-US>&nbsp;&nbsp; T1 func(T2
arg)</span></p>

<p class=a3 style="BACKGROUND: #d9d9d9"><span lang=EN-US>&nbsp;&nbsp; {</span></p>

<p class=a3 style="BACKGROUND: #d9d9d9"><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
T1 var;</span></p>

<p class=a3 style="BACKGROUND: #d9d9d9"><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
... // </span><span style="FONT-FAMILY: 宋体">处理</span><span lang=EN-US>var</span><span
 style="FONT-FAMILY: 宋体">过程</span></p>

<p class=a3 style="BACKGROUND: #d9d9d9"><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
return var;</span></p>

<p class=a3 style="BACKGROUND: #d9d9d9"><span lang=EN-US>&nbsp;&nbsp; }</span></p>

<p class=a3 style="BACKGROUND: #d9d9d9"><span lang=EN-US></span>&nbsp;</p>

<p class=a3 style="BACKGROUND: #d9d9d9"><span lang=EN-US>&nbsp;&nbsp; void
test()</span></p>

<p class=a3 style="BACKGROUND: #d9d9d9"><span lang=EN-US>&nbsp;&nbsp; {</span></p>

<p class=a3 style="BACKGROUND: #d9d9d9"><span lang=EN-US>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;int result1 = 
  func&lt;int&gt;(1);</span></p>

<p class=a3 style="BACKGROUND: #d9d9d9"><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double result2 =
   func&lt;double&gt;(2);</span></p>

<p class=a3 style="BACKGROUND: #d9d9d9"><span lang=EN-US>&nbsp;&nbsp; };</span></p>

<p class=MsoNormal><span lang=EN-US></span>&nbsp;</p>

<p class=MsoNormal><span style="FONT-FAMILY: 宋体">很抱歉，这种用法</span><span
 lang=EN-US>VC++ 6.0</span><span style="FONT-FAMILY: 宋体">不支持。让人恼火的是，</span><span
 lang=EN-US>VC++ 6.0</span><span style="FONT-FAMILY: 宋体">编译时不会提示错误，但是生成的执行代码却很成问题。</span></p>

<p class=MsoNormal><span lang=EN-US></span>&nbsp;</p>

<p class=MsoNormal><span style="FONT-FAMILY: 宋体">究其原因，是因为</span><span
 lang=EN-US>VC++ 6.0</span><span style="FONT-FAMILY: 宋体">的</span><span
 lang=EN-US>template</span><span style="FONT-FAMILY: 宋体">技术是在编译器的较高层次做的，真正的编译器核心并不考虑模板。以上面的代码为例，对编译器核心来说，只是有两个重载函数而已：</span></p>

<p class=MsoNormal><span lang=EN-US></span>&nbsp;</p>

<p class=a3 style="BACKGROUND: #d9d9d9"><span lang=EN-US>&nbsp;&nbsp; int
func(int arg);</span></p>

<p class=a3 style="BACKGROUND: #d9d9d9"><span lang=EN-US>&nbsp;&nbsp; double
func(int arg);</span></p>

<p class=MsoNormal><span lang=EN-US></span>&nbsp;</p>

<p class=MsoNormal><span style="FONT-FAMILY: 宋体">如果是普通情况，只是返回值不同的函数，是不能同时存在的，编译器应该认为这是一个错误。但是很在模板情况下，这两个函数被简单认为是同一个函数。因为</span><span
 lang=EN-US>VC++ 6.0</span><span style="FONT-FAMILY: 宋体">会为每个函数根据它的：</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;&nbsp; 1</span><span
 style="FONT-FAMILY: 宋体">）所在的</span><span lang=EN-US>namespace</span><span
 style="FONT-FAMILY: 宋体">；</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;&nbsp; 2</span><span
 style="FONT-FAMILY: 宋体">）所在的类的类名（如果是成员函数）；</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;&nbsp; 3</span><span
 style="FONT-FAMILY: 宋体">）函数名；</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;&nbsp; 4</span><span
 style="FONT-FAMILY: 宋体">）函数调用方式（</span><span lang=EN-US>cdecl</span><span
 style="FONT-FAMILY: 宋体">、</span><span lang=EN-US>stdcall</span><span
 style="FONT-FAMILY: 宋体">还是</span><span lang=EN-US>fastcall</span><span
 style="FONT-FAMILY: 宋体">）；</span></p>

<p class=MsoNormal><span lang=EN-US>&nbsp;&nbsp; 5</span><span
 style="FONT-FAMILY: 宋体">）所有参数的类型；</span></p>

<p class=MsoNormal><span style="FONT-FAMILY: 宋体">而生成一个唯一标识该函数的函数名。这个过程叫</span><span
 lang=EN-US>Name Mangling</span><span style="FONT-FAMILY: 宋体">，是所有</span><span
 lang=EN-US>C++</span><span style="FONT-FAMILY: 宋体">编译器都要进行的工作。而另一个背景是，很多</span><span
 lang=EN-US>C++</span><span style="FONT-FAMILY: 宋体">编译器生成的目标文件（</span><span
 lang=EN-US>.obj</span><span style="FONT-FAMILY: 宋体">文件）有一些和模板相关的特殊信息，包括也标识了某个函数是否模板函数。这是因为一个模板函数在多个源文件（</span><span
 lang=EN-US>.cpp</span><span style="FONT-FAMILY: 宋体">文件）中被调用的话，这个模板函数就会在这些源文件编译生成的目标文件（</span><span
 lang=EN-US>.obj</span><span style="FONT-FAMILY: 宋体">文件）中都定义（</span><span
 lang=EN-US>definition</span><span style="FONT-FAMILY: 宋体">）一份。为了支持模板，</span><span
 lang=EN-US>link</span><span style="FONT-FAMILY: 宋体">程序显然必须知道这个函数是模板函数，从而随意选择一个定义（丢弃其余的定义），而不是报符号重复定义错误。</span></p>

<p class=MsoNormal><span lang=EN-US></span>&nbsp;</p>

<p class=MsoNormal><span style="FONT-FAMILY: 宋体">因为函数名、参数列表等完全一致，所以这两个函数</span><span
 lang=EN-US>Name Mangling</span><span style="FONT-FAMILY: 宋体">后生成的名字是一样的，并且，它们都被标识为这是模板函数。从而，</span><span
 lang=EN-US>link</span><span style="FONT-FAMILY: 宋体">程序在工作的时候，简单地将其中一个函数定义给抛弃了。</span></p>

<p class=MsoNormal><span lang=EN-US></span>&nbsp;</p>

<p class=MsoNormal><span style="FONT-FAMILY: 宋体">那么，如果我们非要提供上述的</span><span
 lang=EN-US>func</span><span style="FONT-FAMILY: 宋体">函数，怎么办？我们来点花招：</span></p>

<p class=MsoNormal><span lang=EN-US></span>&nbsp;</p>

<p class=a3 style="BACKGROUND: #d9d9d9"><span lang=EN-US>template &lt;class
T1&gt;</span></p>

<p class=a3 style="BACKGROUND: #d9d9d9"><span lang=EN-US>class func</span></p>

<p class=a3 style="BACKGROUND: #d9d9d9"><span lang=EN-US>{</span></p>

<p class=a3 style="BACKGROUND: #d9d9d9"><span lang=EN-US>private:</span></p>

<p class=a3 style="BACKGROUND: #d9d9d9"><span lang=EN-US>&nbsp;&nbsp;&nbsp; T1
var;</span></p>

<p class=a3 style="BACKGROUND: #d9d9d9"><span lang=EN-US></span>&nbsp;</p>

<p class=a3 style="BACKGROUND: #d9d9d9"><span lang=EN-US>public:</span></p>

<p class=a3 style="BACKGROUND: #d9d9d9"><span lang=EN-US>&nbsp;&nbsp;&nbsp;
template &lt;class T2&gt;</span></p>

<p class=a3 style="BACKGROUND: #d9d9d9"><span lang=EN-US>&nbsp;&nbsp;&nbsp;
func(T2 arg)</span></p>

<p class=a3 style="BACKGROUND: #d9d9d9"><span lang=EN-US>&nbsp;&nbsp;&nbsp; {</span></p>

<p class=a3 style="BACKGROUND: #d9d9d9"><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
... // </span><span style="FONT-FAMILY: 宋体">处理</span><span lang=EN-US>var</span><span
 style="FONT-FAMILY: 宋体">过程</span></p>

<p class=a3 style="BACKGROUND: #d9d9d9"><span lang=EN-US>&nbsp;&nbsp;&nbsp; }</span></p>

<p class=a3 style="BACKGROUND: #d9d9d9"><span lang=EN-US>&nbsp;&nbsp;&nbsp;
operator T1() const</span></p>

<p class=a3 style="BACKGROUND: #d9d9d9"><span lang=EN-US>&nbsp;&nbsp;&nbsp; {</span></p>

<p class=a3 style="BACKGROUND: #d9d9d9"><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
return var;</span></p>

<p class=a3 style="BACKGROUND: #d9d9d9"><span lang=EN-US>&nbsp;&nbsp;&nbsp; }</span></p>

<p class=a3 style="BACKGROUND: #d9d9d9"><span lang=EN-US>};</span></p>

<p class=MsoNormal><span lang=EN-US></span>&nbsp;</p>

<p class=MsoNormal><span style="FONT-FAMILY: 宋体">我们再来使用</span><span lang=EN-US>func</span><span
 style="FONT-FAMILY: 宋体">这个</span><span lang=EN-US>“</span><span
 style="FONT-FAMILY: 宋体">函数</span><span lang=EN-US>”</span><span
 style="FONT-FAMILY: 宋体">：</span></p>

<p class=MsoNormal><span lang=EN-US></span>&nbsp;</p>

<p class=a3 style="BACKGROUND: #d9d9d9"><span lang=EN-US>&nbsp;&nbsp; void
test()</span></p>

<p class=a3 style="BACKGROUND: #d9d9d9"><span lang=EN-US>&nbsp;&nbsp; {</span></p>

<p class=a3 style="BACKGROUND: #d9d9d9"><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int result1 =
   func&lt;int&gt;(1);</span></p>

<p class=a3 style="BACKGROUND: #d9d9d9"><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; double result2 =
   func&lt;double&gt;(2);</span></p>

<p class=a3 style="BACKGROUND: #d9d9d9"><span lang=EN-US>&nbsp;&nbsp; };</span></p>

<p class=MsoNormal><span lang=EN-US></span>&nbsp;</p>

<p class=MsoNormal><span style="FONT-FAMILY: 宋体">呵呵，你会发现，它还真象是你期望的正常工作。</span></p>

<p class=MsoNormal><span lang=EN-US></span>&nbsp;</p>

<p class=MsoNormal><span lang=EN-US></span>&nbsp;</p>

<p class=MsoNormal><b><span lang=EN-US>3</span></b><b><span style="FONT-FAMILY:
 宋体">）仿真</span><span lang=EN-US>VC++</span></b><b><span style="FONT-FAMILY: 宋体">提供的关键字</span><span
 lang=EN-US>__uuidof</span></b><b><span style="FONT-FAMILY: 宋体">。</span></b></p>

<p class=MsoNormal><span lang=EN-US></span>&nbsp;</p>

<p class=MsoNormal><span style="FONT-FAMILY: 宋体">这个技巧不是针对</span><span
 lang=EN-US>VC++ 6.0</span><span style="FONT-FAMILY: 宋体">缺陷的，而是针对</span><span
 lang=EN-US>VC++</span><span style="FONT-FAMILY: 宋体">扩展语法的。这个技巧的来由，是为了某些希望有一天有可能要脱离</span><span
 lang=EN-US>Visual C++</span><span style="FONT-FAMILY: 宋体">环境进行开发的人员。为了脱离</span><span
 lang=EN-US>VC++</span><span style="FONT-FAMILY: 宋体">，你需要谨慎使用它的所有扩展语法。例如本文讨论的</span><span
 lang=EN-US>__uuidof</span><span style="FONT-FAMILY: 宋体">。我们先来看看一个例子：</span></p>

<p class=MsoNormal><span lang=EN-US></span>&nbsp;</p>

<p class=a3 style="BACKGROUND: #d9d9d9"><span lang=EN-US>class
__declspec(uuid("B372C9F6-1959-4650-960D-73F20CD479BA")) Class;</span></p>

<p class=a3 style="BACKGROUND: #d9d9d9"><span lang=EN-US>struct
__declspec(uuid("B372C9F6-1959-4650-960D-73F20CD479BB")) Interface;</span></p>

<p class=a3 style="BACKGROUND: #d9d9d9"><span lang=EN-US></span>&nbsp;</p>

<p class=a3 style="BACKGROUND: #d9d9d9"><span lang=EN-US>void test()</span></p>

<p class=a3 style="BACKGROUND: #d9d9d9"><span lang=EN-US>{</span></p>

<p class=a3 style="BACKGROUND: #d9d9d9"><span lang=EN-US>&nbsp;&nbsp; CLSID
clsid = __uuidof(Class);</span></p>

<p class=a3 style="BACKGROUND: #d9d9d9"><span lang=EN-US>&nbsp;&nbsp; IID iid =   
__uuidof(Interface);</span></p>

<p class=a3 style="BACKGROUND: #d9d9d9"><span lang=EN-US>&nbsp;&nbsp; ...</span></p>

<p class=a3 style="BACKGROUND: #d9d9d9"><span lang=EN-US>}</span></p>

<p class=MsoNormal><span lang=EN-US></span>&nbsp;</p>

<p class=MsoNormal><span style="FONT-FAMILY: 宋体">这比起你以前定义</span><span
 lang=EN-US>uuid</span><span style="FONT-FAMILY: 宋体">的方法简单多了吧？可惜，这样好用的东西，它只在</span><span
 lang=EN-US>VC++</span><span style="FONT-FAMILY: 宋体">中提供。不过没有关系，我们这里介绍一个技巧，可以让你在几乎所有</span><span
 lang=EN-US>C++</span><span style="FONT-FAMILY: 宋体">编译器中都可以这样方便的使用</span><span
 lang=EN-US>__uuidof</span><span style="FONT-FAMILY: 宋体">。这里没有说是所有，是因为我们使用了模板特化技术，可能存在一些比较“古老”的</span><span
 lang=EN-US>C++</span><span style="FONT-FAMILY: 宋体">编译器，不支持该特性。</span></p>

<p class=MsoNormal><span lang=EN-US></span>&nbsp;</p>

<p class=MsoNormal><span style="FONT-FAMILY: 宋体">也许你已经迫不及待了。好，让我们来看看：</span></p>

<p class=MsoNormal><span lang=EN-US></span>&nbsp;</p>

<p class=a3 style="BACKGROUND: #d9d9d9"><span lang=EN-US>#include &lt;string&gt;</span></p>

<p class=a3 style="BACKGROUND: #d9d9d9"><span lang=EN-US>#include
&lt;cassert&gt;</span></p>

<p class=a3 style="BACKGROUND: #d9d9d9"><span lang=EN-US></span>&nbsp;</p>

<p class=a3 style="BACKGROUND: #d9d9d9"><span lang=EN-US>inline</span></p>

<p class=a3 style="BACKGROUND: #d9d9d9"><span lang=EN-US>STDMETHODIMP_(GUID)
GUIDFromString(LPOLESTR lpsz)</span></p>

<p class=a3 style="BACKGROUND: #d9d9d9"><span lang=EN-US>{</span></p>

<p class=a3 style="BACKGROUND: #d9d9d9"><span lang=EN-US>&nbsp;&nbsp;&nbsp;
HRESULT hr;</span></p>

<p class=a3 style="BACKGROUND: #d9d9d9"><span lang=EN-US>&nbsp;&nbsp;&nbsp; GUID
guid;</span></p>

<p class=a3 style="BACKGROUND: #d9d9d9"><span lang=EN-US>&nbsp;&nbsp;&nbsp; if
(lpsz[0] == '{')</span></p>

<p class=a3 style="BACKGROUND: #d9d9d9"><span lang=EN-US>&nbsp;&nbsp;&nbsp; {</span></p>

<p class=a3 style="BACKGROUND: #d9d9d9"><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hr =
  CLSIDFromString(lpsz, &amp;guid);</span></p>

<p class=a3 style="BACKGROUND: #d9d9d9"><span lang=EN-US>&nbsp;&nbsp;&nbsp; }</span></p>

<p class=a3 style="BACKGROUND: #d9d9d9"><span lang=EN-US>&nbsp;&nbsp;&nbsp; else</span></p>

<p class=a3 style="BACKGROUND: #d9d9d9"><span lang=EN-US>&nbsp;&nbsp;&nbsp; {</span></p>

<p class=a3 style="BACKGROUND: #d9d9d9"><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
std::basic_string&lt;OLECHAR&gt; strGuid;</span></p>

<p class=a3 style="BACKGROUND: #d9d9d9"><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
strGuid.append(1, '{');</span></p>

<p class=a3 style="BACKGROUND: #d9d9d9"><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
strGuid.append(lpsz);</span></p>

<p class=a3 style="BACKGROUND: #d9d9d9"><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
strGuid.append(1, '}');</span></p>

<p class=a3 style="BACKGROUND: #d9d9d9"><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hr =
  CLSIDFromString((LPOLESTR)strGuid.c_str(), &amp;guid);</span></p>

<p class=a3 style="BACKGROUND: #d9d9d9"><span lang=EN-US>&nbsp;&nbsp;&nbsp; }</span></p>

<p class=a3 style="BACKGROUND: #d9d9d9"><span lang=EN-US>&nbsp;&nbsp;&nbsp;
assert(hr == S_OK);</span></p>

<p class=a3 style="BACKGROUND: #d9d9d9"><span lang=EN-US>&nbsp;&nbsp;&nbsp;
return guid;</span></p>

<p class=a3 style="BACKGROUND: #d9d9d9"><span lang=EN-US>}</span></p>

<p class=a3 style="BACKGROUND: #d9d9d9"><span lang=EN-US></span>&nbsp;</p>

<p class=a3 style="BACKGROUND: #d9d9d9"><span lang=EN-US>template &lt;class
Class&gt;</span></p>

<p class=a3 style="BACKGROUND: #d9d9d9"><span lang=EN-US>struct _UuidTraits {</span></p>

<p class=a3 style="BACKGROUND: #d9d9d9"><span lang=EN-US>};</span></p>

<p class=a3 style="BACKGROUND: #d9d9d9"><span lang=EN-US></span>&nbsp;</p>

<p class=a3 style="BACKGROUND: #d9d9d9"><span lang=EN-US>#define
_DEFINE_UUID(Class,
uuid)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
\</span></p>

<p class=a3 style="BACKGROUND: #d9d9d9"><span lang=EN-US>
template
&lt;&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\</span></p>

<p class=a3 style="BACKGROUND: #d9d9d9"><span lang=EN-US>
struct
_UuidTraits&lt;Class&gt;
{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\</span></p>

<p class=a3 style="BACKGROUND: #d9d9d9"><span lang=EN-US> &nbsp;&nbsp;&nbsp;
static const GUID&amp;
Guid()
{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\</span></p>

<p class=a3 style="BACKGROUND: #d9d9d9"><span lang=EN-US>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
static GUID guid = GUIDFromString(L ##
uuid);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; \</span></p>

<p class=a3 style="BACKGROUND: #d9d9d9"><span lang=EN-US>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
return
guid;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\</span></p>

<p class=a3 style="BACKGROUND: #d9d9d9"><span lang=EN-US>
&nbsp;&nbsp;&nbsp;
}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\</span></p>

<p class=a3 style="BACKGROUND: #d9d9d9"><span lang=EN-US>}</span></p>

<p class=a3 style="BACKGROUND: #d9d9d9"><span lang=EN-US></span>&nbsp;</p>

<p class=a3 style="BACKGROUND: #d9d9d9"><span lang=EN-US>#define
__uuidof(Class)&nbsp;&nbsp;&nbsp; _UuidTraits&lt;Class&gt;::Guid()</span></p>

<p class=a3 style="BACKGROUND: #d9d9d9"><span lang=EN-US></span>&nbsp;</p>

<p class=a3 style="BACKGROUND: #d9d9d9"><span lang=EN-US>#define
DEFINE_CLSID(Class,
guid)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
\</span></p>

<p class=a3 style="BACKGROUND: #d9d9d9"><span lang=EN-US>
&nbsp;&nbsp;&nbsp;
class
Class;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\</span></p>

<p class=a3 style="BACKGROUND: #d9d9d9"><span lang=EN-US>&nbsp;&nbsp;&nbsp;
_DEFINE_UUID(Class, guid)</span></p>

<p class=a3 style="BACKGROUND: #d9d9d9"><span lang=EN-US></span>&nbsp;</p>

<p class=a3 style="BACKGROUND: #d9d9d9"><span lang=EN-US>#define
DEFINE_IID(Interface,
iid)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
\</span></p>

<p class=a3 style="BACKGROUND: #d9d9d9"><span lang=EN-US>
&nbsp;&nbsp;&nbsp;
struct
Interface;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\</span></p>

<p class=a3 style="BACKGROUND: #d9d9d9"><span lang=EN-US>&nbsp;&nbsp;&nbsp;
_DEFINE_UUID(Interface, iid)</span></p>

<p class=MsoNormal><span lang=EN-US></span>&nbsp;</p>

<p class=MsoNormal><span lang=EN-US></span>&nbsp;</p>

<p class=MsoNormal><span style="FONT-FAMILY: 宋体">这样一来，就已经模拟出一个</span><span
 lang=EN-US>__uuidof</span><span style="FONT-FAMILY: 宋体">关键字。我们可以很方便进行</span><span
 lang=EN-US>uuid</span><span style="FONT-FAMILY: 宋体">的定义。举例如下：</span></p>

<p class=MsoNormal><span lang=EN-US></span>&nbsp;</p>

<p class=a3 style="BACKGROUND: #d9d9d9"><span lang=EN-US>DEFINE_CLSID(Class,
"{B372C9F6-1959-4650-960D-73F20CD479BA}");</span></p>

<p class=a3 style="BACKGROUND: #d9d9d9"><span lang=EN-US>DEFINE_IID(Interface,
"{B372C9F6-1959-4650-960D-73F20CD479BB}");</span></p>

<p class=a3 style="BACKGROUND: #d9d9d9"><span lang=EN-US></span>&nbsp;</p>

<p class=a3 style="BACKGROUND: #d9d9d9"><span lang=EN-US>void test()</span></p>

<p class=a3 style="BACKGROUND: #d9d9d9"><span lang=EN-US>{</span></p>

<p class=a3 style="BACKGROUND: #d9d9d9"><span lang=EN-US>&nbsp;&nbsp; CLSID
clsid = __uuidof(Class);</span></p>

<p class=a3 style="BACKGROUND: #d9d9d9"><span lang=EN-US>&nbsp;&nbsp; IID iid =   
__uuidof(Interface);</span></p>

<p class=a3 style="BACKGROUND: #d9d9d9"><span lang=EN-US>&nbsp;&nbsp; ...</span></p>

<p class=a3 style="BACKGROUND: #d9d9d9"><span lang=EN-US>}</span></p>

<p class=MsoNormal><span lang=EN-US></span>&nbsp;</p>

<p class=MsoNormal><span style="FONT-FAMILY: 宋体">在</span><span lang=EN-US>VC++</span><span
 style="FONT-FAMILY: 宋体">中，为了与其他编译器以相同的方式来进行</span><span lang=EN-US>uuid</span><span
 style="FONT-FAMILY: 宋体">的定义，我们不直接使用</span><span lang=EN-US>__declspec(uuid)</span><span
 style="FONT-FAMILY: 宋体">，而是也定义</span><span lang=EN-US>DEFINE_CLSID, DEFINE_IID</span><span
 style="FONT-FAMILY: 宋体">宏：</span></p>

<p class=MsoNormal><span lang=EN-US></span>&nbsp;</p>

<p class=a3 style="BACKGROUND: #d9d9d9"><span lang=EN-US>#define
DEFINE_CLSID(Class,
clsid)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \</span></p>

<p class=a3 style="BACKGROUND: #d9d9d9"><span lang=EN-US>&nbsp;&nbsp;&nbsp;
class __declspec(uuid(clsid)) Class</span></p>

<p class=a3 style="BACKGROUND: #d9d9d9"><span lang=EN-US></span>&nbsp;</p>

<p class=a3 style="BACKGROUND: #d9d9d9"><span lang=EN-US>#define
DEFINE_IID(Interface,
iid)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; \</span></p>

<p class=a3 style="BACKGROUND: #d9d9d9"><span lang=EN-US>&nbsp;&nbsp;&nbsp;
struct __declspec(uuid(iid)) Interface</span></p>

<p class=MsoNormal><span lang=EN-US></span>&nbsp;</p>

<p class=MsoNormal><span style="FONT-FAMILY: 宋体">这样一来，我们已经在所有包含</span><span
 lang=EN-US>VC++</span><span style="FONT-FAMILY: 宋体">在内的支持模板特化技术的编译器中，提供了</span><span
 lang=EN-US>__uuidof</span><span style="FONT-FAMILY: 宋体">关键字。通过它可以进一步简化你在</span><span
 lang=EN-US>C++</span><span style="FONT-FAMILY: 宋体">语言中实现</span><span lang=EN-US>COM</span><span
 style="FONT-FAMILY: 宋体">组件的代价。</span></p>

<p class=MsoNormal><span lang=EN-US></span>&nbsp;</p>

<p class=MsoNormal><span style="FONT-FAMILY: 宋体">附注：关于本文使用的</span><span
 lang=EN-US>C++</span><span style="FONT-FAMILY: 宋体">模板的特化技术，详细请参阅</span><span
 lang=EN-US>C++</span><span style="FONT-FAMILY: 宋体">文法方面的书籍，例如《</span><span
 lang=EN-US>C++ Primer</span><span style="FONT-FAMILY: 宋体">》。其实这个技巧在</span><span
 lang=EN-US>C++</span><span style="FONT-FAMILY: 宋体">标准库――</span><span lang=EN-US>STL</span><span
 style="FONT-FAMILY: 宋体">中有一个专门的名字：</span><span lang=EN-US>traits</span><span
 style="FONT-FAMILY: 宋体">（萃取），你可以在很多介绍</span><span lang=EN-US>STL</span><span
 style="FONT-FAMILY: 宋体">的书籍中见到相关的介绍。</span></p>

</div>

</body>

</html>
